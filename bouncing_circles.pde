import java.util.*;

//g is the gravitational constant
float g = 10;
//t is the timestep used for calculating movement
float t = .1;
//size of the square box generated by processing
int framesize = 500;
boolean gravity = true;
//size of the balls
int ballsize;

//number of balls 
int quantity;
//list of all the balls
ArrayList<Ball> balls;

//set the size of the window number and size of balls and initial position and velocity of the balls
void setup(){ 
  balls = new ArrayList<Ball>();
  quantity = 2;
  ballsize = 50;
  size(500,500);
  balls.add(new Ball(0, ballsize, 50 , 50, 10, 0));
  balls.add(new Ball(1, ballsize, 50 , 250, -10, 0));
}

void draw(){
  background(250); 
  
  //check if any of the balls are colliding in this timestep
  for(Ball ball: balls){
    int coll = ball.iscollision();
    if(coll != -1){
      collide(ball, balls.get(coll));
    }
  }
  
  //update ball position and display the simulation at every timestep
  for(Ball ball: balls){
    ball.update();
    ball.display();
  }
}

//updates the velocities of balls involved in a collision
void collide(Ball a, Ball b){
  //components of a vector from ball a to ball b
  double abx = a.xpos - b.xpos;
  double aby = a.ypos - b.ypos;
  double abmag = (float) Math.sqrt(abx*abx + aby*aby);
  
  if(abmag == 0){
    abx = 1;
    aby = 1;
    abmag = (float) Math.sqrt(abx*abx + aby*aby);
  }

  //components of a vector from ball b to ball a
  double bax = -1 * abx;
  double bay = -1 * aby;
  
  //find the components of velocity that are in the direction of the collision
  double aprojbax = ((a.xvel * bax + a.yvel * bay) * bax)/(abmag*abmag);
  double aprojbay = ((a.xvel * bax + a.yvel * bay) * bay)/(abmag*abmag);
  
  double bprojabx = ((b.xvel * abx + b.yvel * aby) * abx)/(abmag*abmag);
  double bprojaby = ((b.xvel * abx + b.yvel * aby) * aby)/(abmag*abmag);
  
  //balls keep their velocity not in the direction of the collision
  //velocity in the direction of the collision is reversed and split between balls
  double xforce = 0;
  if( aprojbax / Math.abs(aprojbax) == bax / Math.abs(abx)){
    xforce = Math.abs(aprojbax);
    a.xvel = (float) (a.xvel - aprojbax);
  }

  if( bprojabx / Math.abs(bprojabx) == abx / Math.abs(abx)){
    xforce = xforce + Math.abs(bprojabx);
    b.xvel = (float) (b.xvel - bprojabx);
  }
  
  double yforce = 0;
  if( aprojbay / Math.abs(aprojbay) == bay / Math.abs(bay)){
    yforce = Math.abs(aprojbay);
    a.yvel =  (float) (a.yvel - aprojbay);
  }
  if( bprojaby / Math.abs(bprojaby) == aby / Math.abs(aby)){
    yforce = yforce + Math.abs(bprojaby);
    b.yvel = (float) (b.yvel - bprojaby);
  }
  
  //assign new velocities to the balls
  a.xvel = (float) (a.xvel + (abx / Math.abs(abx)) * xforce / 2);
  b.xvel = (float) (b.xvel + (bax / Math.abs(bax)) * xforce / 2);
  
  a.yvel = (float) (a.yvel + (aby / Math.abs(aby)) * yforce / 2);
  b.yvel = (float) (b.yvel + (bay / Math.abs(bay)) * yforce / 2);
  
}


class Ball{
  int me;
  float size;
  float xpos;
  float ypos;
  float xvel;
  float yvel;
  
  //constructor
  Ball(int id, float s, float startxpos, float startypos, float startxvel, float startyvel){
    me = id;
    size = s;
    xpos = startxpos;
    ypos = startypos;
    xvel = startxvel;
    yvel = startyvel;
  }
  
  //these methods check if this ball is touching the edge of the window
  boolean xonedge(){
    return (xpos > (framesize - size/2) || xpos < size/2);
  }
  
  boolean yonedge(){
    return (ypos > (framesize - size/2) || ypos < size/2);
  }
  
  //check is this ball is colliding with any ball with a higher index in the ball list
  int iscollision(){
    if(this.me != quantity - 1){
     for(int i = me + 1; i < balls.size(); i++){
      if(balls.get(i).me != this.me){
        if(distance(balls.get(i)) < size ){
          return balls.get(i).me;
        }
      }
   }
    }
   return -1;
  }

  //find the distance between 2 balls
  double distance(Ball ball1){
    return Math.sqrt( Math.pow(ball1.xpos-this.xpos, 2) + Math.pow(ball1.ypos - this.ypos, 2) );
  }

  //update all the balls in the list
  void update(){
    if(gravity){
      yvel = yvel + g * t;
    }
    
    //TODO fix bug where balls get stuck on edge
    boolean xedge = xonedge();
    boolean yedge = yonedge();
    if(xedge && yedge){
      yvel = -1 * yvel;
      xvel = -1 * xvel;
    }
    else if(yedge){
      yvel = -1 * yvel; 
    }
    else if(xedge){
      xvel = -1 * xvel; 
    }
    xpos = xpos + xvel * t;
    ypos = ypos + yvel * t;
  }
  
  //draw the balls in the window
  //commented lines draw velocity vectors for debugging
  void display(){
    //stroke(0);
    //line(xpos, ypos, xpos+xvel, ypos + yvel);
    //stroke(100);
    //line(xpos, ypos, xpos + xvel, ypos);
    //line(xpos, ypos, xpos, ypos + yvel);
    fill(0, (this.me * 32) % 255 , (this.me * 50) % 255);
    ellipse(xpos, ypos, size, size);
  }
}
